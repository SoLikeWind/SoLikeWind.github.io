<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go Web | GoXny</title><meta name="author" content="仙逆源"><meta name="copyright" content="仙逆源"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Go Web框架">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Web">
<meta property="og:url" content="http://goxny.cn/2024/02/04/Go%20Web/index.html">
<meta property="og:site_name" content="GoXny">
<meta property="og:description" content="Go Web框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg">
<meta property="article:published_time" content="2024-02-04T13:10:49.000Z">
<meta property="article:modified_time" content="2024-03-06T11:17:49.000Z">
<meta property="article:author" content="仙逆源">
<meta property="article:tag" content="人生多少演绎，少年大胆前去。">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://goxny.cn/2024/02/04/Go%20Web/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go Web',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-06 19:17:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/07/21/kSAnu51VpGl4osQ.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="GoXny"><span class="site-name">GoXny</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go Web</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-04T13:10:49.000Z" title="发表于 2024-02-04 21:10:49">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-06T11:17:49.000Z" title="更新于 2024-03-06 19:17:49">2024-03-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go Web"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/02/04/Go%20Web/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/02/04/Go%20Web/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>书籍推荐及笔记参考：《Go Web 编程》 谢孟军</p>
<h1 id="一、Web-基础"><a href="#一、Web-基础" class="headerlink" title="一、Web 基础"></a>一、Web 基础</h1><h2 id="1-web工作方式"><a href="#1-web工作方式" class="headerlink" title="1.web工作方式"></a>1.web工作方式</h2><p>对于普通的上网过程，系统其实是这样做的：浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP，然后通过IP地址找到IP对应的服务器后，要求建立TCP连接，等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。</p>
<img src="https://static.sitestack.cn/projects/Go-Web/d3014042bf5a1c121681661ab034702c.png" alt="web工作方式 - 图1" style="zoom:67%;" />

<p>Web服务器的工作原理可以简单地归纳为：</p>
<ul>
<li>客户机通过TCP/IP协议建立到服务器的TCP连接</li>
<li>客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档</li>
<li>服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端</li>
<li>客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果</li>
</ul>
<p>一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。</p>
<h3 id="i-URL和DNS解析"><a href="#i-URL和DNS解析" class="headerlink" title="i. URL和DNS解析"></a><font color='orange'>i. URL和DNS解析</font></h3><p>URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line">scheme         指定低层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP服务器的IP地址或者域名</span><br><span class="line">port#          HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/</span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给http服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure>

<p>DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它从事将主机名或域名转换为实际IP地址的工作。</p>
<img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407290848400.png" alt="web工作方式 - 图2" style="zoom: 80%;" />

<ol>
<li>在浏览器中输入<a target="_blank" rel="noopener" href="http://www.qq.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a></li>
<li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li>
<li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li>
<li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li>
<li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a target="_blank" rel="noopener" href="http://www.qq.com主机./">www.qq.com主机。</a></li>
<li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</li>
</ol>
<p><img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407290853548.png" alt="web工作方式 - 图3"></p>
<blockquote>
<p>所谓 <code>递归查询过程</code> 就是 “查询的递交者” 更替, 而 <code>迭代查询过程</code> 则是 “查询的递交者”不变。</p>
<p>举个例子来说，你想知道某个一起上法律课的女孩的电话，并且你偷偷拍了她的照片，回到寝室告诉一个很仗义的哥们儿，这个哥们儿二话没说，拍着胸脯告诉你，甭急，我替你查(此处完成了一次递归查询，即，问询者的角色更替)。然后他拿着照片问了学院大四学长，学长告诉他，这姑娘是xx系的；然后这哥们儿马不停蹄又问了xx系的办公室主任助理同学，助理同学说是xx系yy班的，然后很仗义的哥们儿去xx系yy班的班长那里取到了该女孩儿电话。(此处完成若干次迭代查询，即，问询者角色不变，但反复更替问询对象)最后，他把号码交到了你手里。完成整个查询过程。</p>
</blockquote>
<p>通过上面的步骤，我们<font color='red'>最后获取的是IP地址</font>，也就是浏览器最后发起请求的时候是基于<font color='red'>IP来和服务器做信息交互</font>的。</p>
<h3 id="ii-HTTP协议详解"><a href="#ii-HTTP协议详解" class="headerlink" title="ii. HTTP协议详解"></a><font color='orange'>ii. HTTP协议详解</font></h3><p>HTTP是一种让Web服务器与浏览器(客户端)通过Internet发送与接收数据的协议,它建立在TCP协议之上，一般采用TCP的80端口。它是一个请求、响应协议—客户端发出一个请求，服务器响应这个请求。在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。</p>
<p>HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web程序引入了Cookie机制来维护连接的可持续状态。</p>
<p><font color='orange'>HTTP请求包（浏览器信息）</font></p>
<p>Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /domains/example/ HTTP/1.1        //请求行: 请求方法 请求URI HTTP协议/协议版本</span><br><span class="line">Host：www.iana.org                //服务端的主机名</span><br><span class="line">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4            //浏览器信息</span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    //客户端能接收的mine</span><br><span class="line">Accept-Encoding：gzip,deflate,sdch        //是否支持流压缩</span><br><span class="line">Accept-Charset：UTF-8,*;q=0.5        //客户端字符编码集</span><br><span class="line">//空行,用于分割请求头和消息体</span><br><span class="line">//消息体,请求资源参数,例如POST传递的参数</span><br></pre></td></tr></table></figure>

<p>HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，增，改，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>
<p><font color='purple'><strong>GET和POST的区别:</strong></font></p>
<ol>
<li>我们可以看到GET请求消息体为空，POST请求带有消息体。</li>
<li>GET提交的数据会放在URL之后，以<code>?</code>分割URL和传输数据，参数之间以<code>&amp;</code>相连，如<code>EditPosts.aspx?name=test1&amp;id=123456</code>。POST方法是把提交的数据放在HTTP包的body中。</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ol>
<p><font color='orange'>HTTP响应包（服务器信息）</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK                        //状态行</span><br><span class="line">Server: nginx/1.0.8                    //服务器使用的WEB软件名及版本</span><br><span class="line">Date:Date: Tue, 30 Oct 2012 04:14:25 GMT        //发送时间</span><br><span class="line">Content-Type: text/html                //服务器发送信息的类型</span><br><span class="line">Transfer-Encoding: chunked            //表示发送HTTP包是分段发的</span><br><span class="line">Connection: keep-alive                //保持连接状态</span><br><span class="line">Content-Length: 90                    //主体内容长度</span><br><span class="line">//空行 用来分割消息头和主体</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体</span><br></pre></td></tr></table></figure>

<p>状态码由三位数字组成，第一个数字定义了响应的类别</p>
<ul>
<li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX 成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li>
<li>5XX 服务器端错误 - 服务器未能实现合法的请求</li>
</ul>
<p><font color='purple'><strong>HTTP协议是无状态的和Connection: keep-alive的区别</strong></font></p>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。</p>
<p>从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p>
<p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间。</p>
<hr>
<p>浏览器的一个功能，第一次请求url，服务器端返回的是html页面，然后浏览器开始渲染HTML：当解析到HTML DOM里面的图片连接，css脚本和js脚本的链接，浏览器就会自动发起一个请求静态资源的HTTP请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。</p>
<hr>
<h2 id="2-搭建Web服务"><a href="#2-搭建Web服务" class="headerlink" title="2.搭建Web服务"></a>2.搭建Web服务</h2><p>Go语言里面提供了一个完善的net/http包，通过http包可以很方便的就搭建起来一个可以运行的Web服务。同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func sayhelloName(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    r.ParseForm()  //解析参数，默认是不会解析的</span><br><span class="line">    fmt.Println(r.Form)  //这些信息是输出到服务器端的打印信息</span><br><span class="line">    fmt.Println(&quot;path&quot;, r.URL.Path)</span><br><span class="line">    fmt.Println(&quot;scheme&quot;, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[&quot;url_long&quot;])</span><br><span class="line">    for k, v := range r.Form &#123;</span><br><span class="line">        fmt.Println(&quot;key:&quot;, k)</span><br><span class="line">        fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, &quot;Hello astaxie!&quot;) //这个写入到w的是输出到客户端的</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, sayhelloName) //设置访问的路由</span><br><span class="line">    err := http.ListenAndServe(&quot;:9090&quot;, nil) //设置监听的端口</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(&quot;ListenAndServe: &quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-web工作"><a href="#3-web工作" class="headerlink" title="3.web工作"></a>3.web工作</h2><p><font color='purple'><strong>web工作方式的几个概念：</strong></font></p>
<p>Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息</p>
<p>Response：服务器需要反馈给客户端的信息</p>
<p>Conn：用户的每次请求链接</p>
<p>Handler：处理请求和生成返回信息的处理逻辑</p>
<p><strong>Go实现Web服务的工作模式的流程图：</strong></p>
<p><img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407291000933.png" alt="Go如何使得web工作 - 图1"></p>
<ol>
<li>创建Listen Socket, 监听指定的端口, 等待客户端请求到来。</li>
<li>Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。</li>
<li>处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。</li>
</ol>
<ul>
<li>如何监听端口？</li>
<li>如何接收客户端请求？</li>
<li>如何分配handler？</li>
</ul>
<p>用户的每一次请求都是在一个新的<strong>goroutine</strong>去服务，相互不影响。</p>
<p><img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407291010623.png" alt="Go如何使得web工作 - 图2"></p>
<hr>
<p>Go的http有两个核心功能：Conn、ServeMux</p>
<p><font color='purple'><strong>ServeMux的自定义</strong></font></p>
<p>conn.server的时候，其实内部是调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。那么这个路由器是怎么实现的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ServeMux struct &#123;</span><br><span class="line">    mu sync.RWMutex   //锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span><br><span class="line">    m  map[string]muxEntry  // 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span><br><span class="line">    hosts bool // 是否在任意的规则中带有host信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='purple'>http包的执行过程</font></p>
<ul>
<li><p>首先调用Http.HandleFunc</p>
<p>按顺序做了几件事：</p>
<p>1 调用了DefaultServeMux的HandleFunc</p>
<p>2 调用了DefaultServeMux的Handle</p>
<p>3 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则</p>
</li>
<li><p>其次调用http.ListenAndServe(“:9090”, nil)</p>
<p>按顺序做了几件事情：</p>
<p>1 实例化Server</p>
<p>2 调用Server的ListenAndServe()</p>
<p>3 调用net.Listen(“tcp”, addr)监听端口</p>
<p>4 启动一个for循环，在循环体中Accept请求</p>
<p>5 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()</p>
<p>6 读取每个请求的内容w, err := c.readRequest()</p>
<p>7 判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux</p>
<p>8 调用handler的ServeHttp</p>
<p>9 在这个例子中，下面就进入到DefaultServeMux.ServeHttp</p>
<p>10 根据request选择handler，并且进入到这个handler的ServeHTTP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mux.handler(r).ServeHTTP(w, r)</span><br></pre></td></tr></table></figure>

<p>11 选择handler：</p>
<p>A 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）</p>
<p>B 如果有路由满足，调用这个路由handler的ServeHTTP</p>
<p>C 如果没有路由满足，调用NotFoundHandler的ServeHTTP</p>
</li>
</ul>
<hr>
<h1 id="二、表单"><a href="#二、表单" class="headerlink" title="二、表单"></a>二、表单</h1><h2 id="1-验证表单输入"><a href="#1-验证表单输入" class="headerlink" title="1.验证表单输入"></a>1.验证表单输入</h2><p>开发Web的一个原则就是，不能信任用户输入的任何信息，所以验证和过滤用户的输入信息就变得非常重要。</p>
<p>用主要有两方面的数据验证，一个是在页面端的js验证，一个是在服务器端的验证。</p>
<h2 id="2-防止多次递交表单"><a href="#2-防止多次递交表单" class="headerlink" title="2. 防止多次递交表单"></a>2. 防止多次递交表单</h2><p>解决方案是在表单中添加一个带有唯一值的隐藏字段。</p>
<p>在验证表单时，先检查带有该唯一值的表单是否已经递交过了。如果是，拒绝再次递交；如果不是，则处理表单进行逻辑处理。另外，如果是采用了Ajax模式递交表单的话，当表单递交后，通过javascript来禁用表单的递交按钮。</p>
<h2 id="3-处理文件上传"><a href="#3-处理文件上传" class="headerlink" title="3. 处理文件上传"></a>3. 处理文件上传</h2><p>比如需要存储用户拍摄的照片。要使表单能够上传文件，首先第一步就是要添加form的<code>enctype</code>属性</p>
<p><font color='orange'>enctype属性：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class="line">multipart/form-data      不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class="line">text/plain      空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure>

<h1 id="三、访问数据库"><a href="#三、访问数据库" class="headerlink" title="三、访问数据库"></a>三、访问数据库</h1><h2 id="1-sql接口"><a href="#1-sql接口" class="headerlink" title="1.sql接口"></a>1.sql接口</h2><p><strong><font color='purple'>sql.Register</font></strong></p>
<p>用来**<font color='purple'>注册</font>**数据库驱动，当第三方开发者开发数据库驱动时，都会实现init函数，在init里面会调用这个Register(name string, driver driver.Driver)完成本驱动的注册。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//https://github.com/mattn/go-sqlite3驱动</span><br><span class="line">func init() &#123;</span><br><span class="line">    sql.Register(&quot;sqlite3&quot;, &amp;SQLiteDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//https://github.com/mikespook/mymysql驱动</span><br><span class="line">// Driver automatically registered in database/sql</span><br><span class="line">var d = Driver&#123;proto: &quot;tcp&quot;, raddr: &quot;127.0.0.1:3306&quot;&#125;</span><br><span class="line">func init() &#123;</span><br><span class="line">    Register(&quot;SET NAMES utf8&quot;)</span><br><span class="line">    sql.Register(&quot;mymysql&quot;, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;database/sql&quot;</span><br><span class="line">     _ &quot;github.com/mattn/go-sqlite3&quot;</span><br><span class="line">)</span><br><span class="line">//这儿使用_的意思是引入后面的包名而不直接使用这个包中定义的函数，变量等资源。</span><br><span class="line">//包在引入的时候会自动调用包的init函数以完成对包的初始化。因此，我们引入上面的数据库驱动包之后会自动去调用init函数，然后在init函数里面注册这个数据库驱动，这样我们就可以在接下来的代码中直接使用这个数据库驱动了。</span><br></pre></td></tr></table></figure>

<h2 id="2-PostgreSQL数据库"><a href="#2-PostgreSQL数据库" class="headerlink" title="2.PostgreSQL数据库"></a>2.PostgreSQL数据库</h2><p>PostgreSQL 是一个自由的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和对专有系统比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server的一种选择。</p>
<p>PostgreSQL是通过<code>$1</code>,<code>$2</code>这种方式来指定要传递的参数，而不是MySQL中的<code>?</code>，另外在sql.Open中的dsn信息的格式也与MySQL的驱动中的dsn格式不一样</p>
<hr>
<h1 id="四、session和数据存储"><a href="#四、session和数据存储" class="headerlink" title="四、session和数据存储"></a>四、session和数据存储</h1><h2 id="1-cookie和session"><a href="#1-cookie和session" class="headerlink" title="1.cookie和session"></a>1.cookie和session</h2><p>Web开发中一个很重要的议题就是如何做好用户的整个浏览过程的控制。</p>
<p>经典的解决方案是cookie和session，cookie机制是一种客户端机制，把用户数据保存在客户端，而session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，每一个网站访客都会被分配给一个唯一的标志符,即sessionID,它的存放形式无非两种:要么经过url传递,要么保存在客户端的cookies里.当然,你也可以将Session保存到数据库里,这样会更安全,但效率方面会有所下降。</p>
<p><strong><font color='purple'>cookie和session的由来：</font></strong></p>
<p>当用户来到微博登陆页面，输入用户名和密码之后点击“登录”后浏览器将认证信息POST给远端的服务器，服务器执行验证逻辑，如果验证通过，则浏览器会跳转到登录用户的微博首页，在登录成功后，服务器如何验证我们对其他受限制页面的访问呢？因为HTTP协议是无状态的，所以很显然服务器不可能知道我们已经在上一次的HTTP请求中通过了验证。当然，最简单的解决方案就是所有的请求里面都带上用户名和密码，这样虽然可行，但大大加重了服务器的负担（对于每个request都需要到数据库验证），也大大降低了用户体验(每个页面都需要重新输入用户名密码，每个页面都带有登录表单)。</p>
<p>既然直接在请求中带上用户名与密码不可行，那么就只有<strong>在服务器或客户端保存一些类似的可以代表身份的信息</strong>了，所以就有了cookie与session。</p>
<img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407302339578.png" alt="session和cookie - 图1" style="zoom:67%;" />

<p>cookie，简而言之就是在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。</p>
<p>session，简而言之就是在服务器上保存用户操作的历史信息。服务器使用session id来标识session，session id由服务器负责产生，保证随机性与唯一性，相当于一个随机密钥，避免在握手或传输中暴露用户真实密码。但该方式下，仍然需要将发送请求的客户端与session进行对应，所以可以借助cookie机制来获取客户端的标识（即session id），也可以通过GET方式将id提交给服务器。</p>
<img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407302340446.png" alt="session和cookie - 图2" style="zoom:67%;" />

<p>Go语言中通过net/http包中的SetCookie来设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.SetCookie(w ResponseWriter, cookie *Cookie)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-session管理设计"><a href="#2-session管理设计" class="headerlink" title="2.session管理设计"></a>2.session管理设计</h2><p>session管理涉及到如下几个因素</p>
<ul>
<li>全局session管理器</li>
<li>保证sessionid 的全局唯一性</li>
<li>为每个客户关联一个session</li>
<li>session 的存储(可以存储到内存、文件、数据库等)</li>
<li>session 过期处理</li>
</ul>
<hr>
<h1 id="五、文本文件处理"><a href="#五、文本文件处理" class="headerlink" title="五、文本文件处理"></a>五、文本文件处理</h1><h2 id="1-JSON处理"><a href="#1-JSON处理" class="headerlink" title="1.JSON处理"></a>1.JSON处理</h2><p>JSON（Javascript Object Notation）是一种轻量级的数据交换语言，以文字为基础，具有自我描述性且易于让人阅读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;servers&quot;:[&#123;&quot;serverName&quot;:&quot;Shanghai_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;serverName&quot;:&quot;Beijing_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color='purple'>解析JSON</font></strong></p>
<p><strong>解析到结构体：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Server struct &#123;</span><br><span class="line">    ServerName string</span><br><span class="line">    ServerIP   string</span><br><span class="line">&#125;</span><br><span class="line">type Serverslice struct &#123;</span><br><span class="line">    Servers []Server</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var s Serverslice</span><br><span class="line">    str := `&#123;&quot;servers&quot;:[&#123;&quot;serverName&quot;:&quot;Shanghai_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;serverName&quot;:&quot;Beijing_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;`</span><br><span class="line">    json.Unmarshal([]byte(str), &amp;s)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析到interface：</strong></p>
<p>如果不知道被解析的数据的格式，采用下面的方法。</p>
<p>interface{}可以用来存储任意数据类型的对象，这种数据结构正好用于存储解析的未知结构的json数据的结果。</p>
<ul>
<li>bool 代表 JSON booleans,</li>
<li>float64 代表 JSON numbers,</li>
<li>string 代表 JSON strings,</li>
<li>nil 代表 JSON null.</li>
</ul>
<hr>
<p><font color='purple'><strong>生成JSON</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br></pre></td></tr></table></figure>

<p>假设需要生成上面的服务器列表信息，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var s Serverslice</span><br><span class="line">    s.Servers = append(s.Servers, Server&#123;ServerName: &quot;Shanghai_VPN&quot;, ServerIP: &quot;127.0.0.1&quot;&#125;)</span><br><span class="line">    s.Servers = append(s.Servers, Server&#123;ServerName: &quot;Beijing_VPN&quot;, ServerIP: &quot;127.0.0.2&quot;&#125;)</span><br><span class="line">    b, err := json.Marshal(s)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;json err:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(string(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们看到上面的输出字段名的首字母都是大写的，如果你想用小写的首字母怎么办呢？把结构体的字段名改成首字母小写的？JSON输出的时候必须注意，只有导出的字段才会被输出，如果修改字段名，那么就会发现什么都不会输出，所以必须通过struct tag定义来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Server struct &#123;</span><br><span class="line">    ServerName string `json:&quot;serverName&quot;`</span><br><span class="line">    ServerIP   string `json:&quot;serverIP&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type Serverslice struct &#123;</span><br><span class="line">    Servers []Server `json:&quot;servers&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对JSON的输出，我们在定义struct tag的时候需要注意的几点是:</p>
<ul>
<li>字段的tag是<code>&quot;-&quot;</code>，那么这个字段不会输出到JSON</li>
<li>tag中带有自定义名称，那么这个自定义名称会出现在JSON的字段名中，例如上面例子中serverName</li>
<li>tag中如果带有<code>&quot;omitempty&quot;</code>选项，那么如果该字段值为空，就不会输出到JSON串中</li>
<li>如果字段类型是bool, string, int, int64等，而tag中带有<code>&quot;,string&quot;</code>选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Server struct &#123;</span><br><span class="line">    // ID 不会导出到JSON中</span><br><span class="line">    ID int `json:&quot;-&quot;`</span><br><span class="line">    // ServerName2 的值会进行二次JSON编码</span><br><span class="line">    ServerName  string `json:&quot;serverName&quot;`</span><br><span class="line">    ServerName2 string `json:&quot;serverName2,string&quot;`</span><br><span class="line">    // 如果 ServerIP 为空，则不输出到JSON串中</span><br><span class="line">    ServerIP   string `json:&quot;serverIP,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line">s := Server &#123;</span><br><span class="line">    ID:         3,</span><br><span class="line">    ServerName:  `Go &quot;1.0&quot; `,</span><br><span class="line">    ServerName2: `Go &quot;1.0&quot; `,</span><br><span class="line">    ServerIP:   ``,</span><br><span class="line">&#125;</span><br><span class="line">b, _ := json.Marshal(s)</span><br><span class="line">os.Stdout.Write(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输出内容</span><br><span class="line">&#123;&quot;serverName&quot;:&quot;Go \&quot;1.0\&quot; &quot;,&quot;serverName2&quot;:&quot;\&quot;Go \\\&quot;1.0\\\&quot; \&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-正则处理"><a href="#2-正则处理" class="headerlink" title="2.正则处理"></a>2.正则处理</h2><p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。</p>
<p><code>regexp</code>包中含有三个函数用来判断是否匹配，如果匹配返回true，否则返回false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func Match(pattern string, b []byte) (matched bool, error error)</span><br><span class="line">func MatchReader(pattern string, r io.RuneReader) (matched bool, error error)</span><br><span class="line">func MatchString(pattern string, s string) (matched bool, error error)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-模板处理"><a href="#3-模板处理" class="headerlink" title="3.模板处理"></a>3.模板处理</h2><p>模板中如何插入数据</p>
<h3 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h3><p>Go语言的模板通过<code>&#123;&#123;&#125;&#125;`来包含需要在渲染时被替换的字段，`&#123;&#123;.&#125;&#125;</code>表示当前的对象，这和Java或者C++中的this类似，如果要访问当前对象的字段通过<code>&#123;&#123;.FieldName&#125;&#125;</code>，但是需要注意一点：这个字段必须是导出的(字段首字母必须是大写的)，否则在渲染的时候就会报错</p>
<p>如果模板中输出<code>&#123;&#123;.&#125;&#125;</code>，这个一般应用于字符串对象，默认会调用fmt包输出字符串的内容。</p>
<h1 id="六、Web服务"><a href="#六、Web服务" class="headerlink" title="六、Web服务"></a>六、Web服务</h1><h2 id="1-Socket编程"><a href="#1-Socket编程" class="headerlink" title="1.Socket编程"></a>1.Socket编程</h2><p>网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。</p>
<p>Socket也具有一个类似于打开文件的函数调用：<font color='orange'><code>Socket()</code></font>，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p>
<p>Socket类型有两种：流式Socket（SOCK_STREAM，TCP）和数据报式Socket（SOCK_DGRAM，UDP）。</p>
<p>流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。</p>
<p><strong><font color='purple'>Socket通信</font></strong></p>
<p>网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用**<font color='orange'>三元组（ip地址，协议，端口）</font>**就可以标识网络的进程了，网络中需要互相通信的进程，就可以利用这个标志在他们之间进行交互。</p>
<p>net包中的<font color='red'><code>ParseIP(s string) IP</code></font>函数会把一个IPv4或者IPv6的地址转化成IP类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;net&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    if len(os.Args) != 2 &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, &quot;Usage: %s ip-addr\n&quot;, os.Args[0])</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    name := os.Args[1]</span><br><span class="line">    addr := net.ParseIP(name)</span><br><span class="line">    if addr == nil &#123;</span><br><span class="line">        fmt.Println(&quot;Invalid address&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;The address is &quot;, addr.String())</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><font color='purple'>TCP Socket</font></strong></p>
<p>Go语言的<code>net</code>包中有一个类型<code>TCPConn</code>，这个类型可以用来作为客户端和服务器端交互的通道，他有两个主要的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (c *TCPConn) Write(b []byte) (int, error)</span><br><span class="line">func (c *TCPConn) Read(b []byte) (int, error)</span><br></pre></td></tr></table></figure>

<p><code>TCPConn</code>可以用在客户端和服务器端来读写数据。</p>
<p><font color='orange'><code>TCPAddr</code></font>类型，他表示一个TCP的地址信息，他的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type TCPAddr struct &#123;</span><br><span class="line">    IP IP</span><br><span class="line">    Port int</span><br><span class="line">    Zone string // IPv6 scoped addressing zone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-WebSocket"><a href="#2-WebSocket" class="headerlink" title="2.WebSocket"></a>2.WebSocket</h2><p>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道。且此连接会保持在活动状态，你可以使用JavaScript来向连接写入或从中接收数据，就像在使用一个常规的TCP Socket一样。它解决了Web实时化的问题，相比传统HTTP有如下好处：</p>
<ul>
<li>一个Web客户端只建立一个TCP连接</li>
<li>Websocket服务端可以推送(push)数据到web客户端.</li>
<li>有更加轻量级的头，减少数据传送量</li>
</ul>
<p><strong><font color='purple'>WebSocket原理</font></strong></p>
<p>在第一次handshake通过以后，连接便建立成功，其后的通讯数据都是以”\x00″开头，以”\xFF”结尾。在客户端，这个是透明的，WebSocket组件会自动将原始数据“掐头去尾”。</p>
<p>浏览器发出WebSocket连接请求，然后服务器发出回应，然后连接建立成功，这个过程通常称为“握手” (handshaking)。</p>
<p><font color='purple'><strong>Go实现WebSocket</strong></font></p>
<p>获取包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/net/websocket</span><br></pre></td></tr></table></figure>

<p>用户输入信息，客户端通过WebSocket将信息发送给服务器端，服务器端收到信息之后主动Push信息到客户端，然后客户端将输出其收到的信息，客户端的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var sock = null;</span><br><span class="line">        var wsuri = &quot;ws://127.0.0.1:1234&quot;;</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">            console.log(&quot;onload&quot;);</span><br><span class="line">            sock = new WebSocket(wsuri);</span><br><span class="line">            sock.onopen = function() &#123;</span><br><span class="line">                console.log(&quot;connected to &quot; + wsuri);</span><br><span class="line">            &#125;</span><br><span class="line">            sock.onclose = function(e) &#123;</span><br><span class="line">                console.log(&quot;connection closed (&quot; + e.code + &quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sock.onmessage = function(e) &#123;</span><br><span class="line">                console.log(&quot;message received: &quot; + e.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        function send() &#123;</span><br><span class="line">            var msg = document.getElementById(&#x27;message&#x27;).value;</span><br><span class="line">            sock.send(msg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;h1&gt;WebSocket Echo Test&lt;/h1&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            Message: &lt;input id=&quot;message&quot; type=&quot;text&quot; value=&quot;Hello, world!&quot;&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;button onclick=&quot;send();&quot;&gt;Send Message&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到客户端JS，很容易的就通过WebSocket函数建立了一个与服务器的连接sock，当握手成功后，会触发WebScoket对象的onopen事件，告诉客户端连接已经成功建立。客户端一共绑定了四个事件。</p>
<ul>
<li>1）onopen 建立连接后触发</li>
<li>2）onmessage 收到消息后触发</li>
<li>3）onerror 发生错误时触发</li>
<li>4）onclose 关闭连接时触发</li>
</ul>
<p>服务器端的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;golang.org/x/net/websocket&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line">func Echo(ws *websocket.Conn) &#123;</span><br><span class="line">    var err error</span><br><span class="line">    for &#123;</span><br><span class="line">        var reply string</span><br><span class="line">        if err = websocket.Message.Receive(ws, &amp;reply); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;Can&#x27;t receive&quot;)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(&quot;Received back from client: &quot; + reply)</span><br><span class="line">        msg := &quot;Received:  &quot; + reply</span><br><span class="line">        fmt.Println(&quot;Sending to client: &quot; + msg)</span><br><span class="line">        if err = websocket.Message.Send(ws, msg); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;Can&#x27;t send&quot;)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    http.Handle(&quot;/&quot;, websocket.Handler(Echo))</span><br><span class="line">    if err := http.ListenAndServe(&quot;:1234&quot;, nil); err != nil &#123;</span><br><span class="line">        log.Fatal(&quot;ListenAndServe:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Rest"><a href="#3-Rest" class="headerlink" title="3.Rest"></a>3.Rest</h2><p>RESTful，是目前最为流行的一种互联网软件架构。</p>
<p><strong><font color='purple'>什么是REST</font></strong></p>
<p>它指的是一组架构约束条件和原则。</p>
<p>Restful架构</p>
<ul>
<li>（1）每一个URI代表一种资源；</li>
<li>（2）客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<p>Web应用要满足REST最重要的原则是:</p>
<p>​    客户端和服务器之间的交互在请求之间是无状态的,即从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外此请求可以由任何可用服务器回答，这十分适合云计算之类的环境。因为是无状态的，所以客户端可以缓存数据以改进性能。</p>
<p>​    另一个重要的REST原则是系统分层，这表示组件无法了解除了与它直接交互的层次以外的组件。通过将系统知识限制在单个层，可以限制整个系统的复杂性，从而促进了底层的独立性。</p>
<ul>
<li>HTML标准只能通过链接和表单支持<code>GET</code>和<code>POST</code>。在没有Ajax支持的网页浏览器中不能发出<code>PUT</code>或<code>DELETE</code>命令</li>
<li>有些防火墙会挡住HTTP <code>PUT</code>和<code>DELETE</code>请求，要绕过这个限制，客户端需要把实际的<code>PUT</code>和<code>DELETE</code>请求通过 POST 请求穿透过来。RESTful 服务则要负责在收到的 POST 请求中找到原始的 HTTP 方法并还原。</li>
</ul>
<hr>
<h2 id="4-RPC"><a href="#4-RPC" class="headerlink" title="4.RPC"></a>4.RPC</h2><p>​    RPC（Remote Procedure Call Protocol）——远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如TCP或UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<img src="https://static.sitestack.cn/projects/Go-Web/0d8ba424a7517c90b4bdd0a3eeac7454.png" alt="RPC - 图1" style="zoom:67%;" />

<p>运行时,一次客户机对服务器的RPC调用,其内部操作大致有如下十步：</p>
<ul>
<li>1.调用客户端句柄；执行传送参数</li>
<li>2.调用本地系统内核发送网络消息</li>
<li>3.消息传送到远程主机</li>
<li>4.服务器句柄得到消息并取得参数</li>
<li>5.执行远程过程</li>
<li>6.执行的过程将结果返回服务器句柄</li>
<li>7.服务器句柄返回结果，调用远程系统内核</li>
<li>8.消息传回本地主机</li>
<li>9.客户句柄由内核接收消息</li>
<li>10.客户接收句柄返回的数据</li>
</ul>
<p><font color='purple'>Go RPC</font>的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：</p>
<ul>
<li>函数必须是导出的(首字母大写)</li>
<li>必须有两个导出类型的参数，</li>
<li>第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的</li>
<li>函数还要有一个返回值error</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (t *T) MethodName(argType T1, replyType *T2) error</span><br></pre></td></tr></table></figure>

<p>T、T1和T2类型必须能被<code>encoding/gob</code>包编解码。</p>
<hr>
<p>任何的RPC都需要通过网络来传递数据，Go RPC可以利用HTTP和TCP来传递数据，利用HTTP的好处是可以直接复用<code>net/http</code>里面的一些函数。</p>
<hr>
<h2 id="5-避免SQL注入"><a href="#5-避免SQL注入" class="headerlink" title="5.避免SQL注入"></a>5.避免SQL注入</h2><p>SQL注入攻击（SQL Injection），简称注入攻击，是Web开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>而造成SQL注入的原因是因为程序没有有效过滤用户的输入，使攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>很多Web开发者没有意识到SQL查询是可以被篡改的，从而把SQL查询当作可信任的命令。殊不知，SQL查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过SQL查询去运行主机系统级的命令。</p>
<hr>
<h1 id="七、设计Web框架"><a href="#七、设计Web框架" class="headerlink" title="七、设计Web框架"></a>七、设计Web框架</h1><h2 id="1-项目规划"><a href="#1-项目规划" class="headerlink" title="1.项目规划"></a>1.项目规划</h2><p>需要做好项目的规划，如何设置目录结构，如何理解整个项目的流程图，当我们理解了应用的执行过程，那么接下来的设计编码就会变得相对容易了</p>
<p><strong><font color='purple'>应用程序流程图</font></strong></p>
<p>博客系统是基于模型-视图-控制器这一设计模式的。MVC是一种将应用程序的逻辑层和表现层进行分离的结构方式。在实践中，由于表现层从Go中分离了出来，所以它允许你的网页中只包含很少的脚本。</p>
<ul>
<li>模型 (Model) 代表<strong>数据结构</strong>。通常来说，模型类将包含取出、插入、更新数据库资料等这些功能。</li>
<li>视图 (View) 是展示给用户的信息的结构及样式。一个视图通常是一个<strong>网页</strong>，但是在Go中，一个视图也可以是一个页面片段，如页头、页尾。它还可以是一个 RSS 页面，或其它类型的“页面”，Go实现的template包已经很好的实现了View层中的部分功能。</li>
<li>控制器 (Controller) 是模型、视图以及其他任何处理HTTP请求所必须的资源之间的<strong>中介</strong>，并生成网页。</li>
</ul>
<p><img src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407312016164.png" alt="项目规划 - 图3"></p>
<ol>
<li>main.go作为应用入口，初始化一些运行博客所需要的基本资源，配置信息，监听端口。</li>
<li>路由功能检查HTTP请求，根据URL以及method来确定谁(控制层)来处理请求的转发资源。</li>
<li>如果缓存文件存在，它将绕过通常的流程执行，被直接发送给浏览器。</li>
<li>安全检测：应用程序控制器调用之前，HTTP请求和任一用户提交的数据将被过滤。</li>
<li>控制器装载模型、核心库、辅助函数，以及任何处理特定请求所需的其它资源，控制器主要负责处理业务逻辑。</li>
<li>输出视图层中渲染好的即将发送到Web浏览器中的内容。如果开启缓存，视图首先被缓存，将用于以后的常规请求。</li>
</ol>
<p><font color='purple'>博客的目录结构</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|——main.go         入口文件</span><br><span class="line">|——conf            配置文件和处理模块</span><br><span class="line">|——controllers     控制器入口</span><br><span class="line">|——models          数据库处理模块</span><br><span class="line">|——utils           辅助函数库</span><br><span class="line">|——static          静态文件目录</span><br><span class="line">|——views           视图库</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-自定义路由设置"><a href="#2-自定义路由设置" class="headerlink" title="2.自定义路由设置"></a>2.自定义路由设置</h2><p>路由器就是根据用户请求的事件信息转发到相应的处理函数(控制层)。</p>
<p>HTTP路由组件负责将HTTP请求交到对应的函数处理(或者是一个struct的方法)</p>
<p>路由在框架中相当于一个事件处理器，而这个事件包括：</p>
<ul>
<li>用户请求的路径(path)(例如:/user/123,/article/123)，当然还有查询串信息(例如?id=11)</li>
<li>HTTP的请求方法(method)(GET、POST、PUT、DELETE、PATCH等)</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://goxny.cn">仙逆源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://goxny.cn/2024/02/04/Go%20Web/">http://goxny.cn/2024/02/04/Go%20Web/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://goxny.cn" target="_blank">GoXny</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/01/Golang/" title="Golang基础"><img class="cover" src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/13/gin/" title="Gin框架"><img class="cover" src="https://blog-1-1326922879.cos.ap-beijing.myqcloud.com/image/202407221318737.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Gin框架</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Web-%E5%9F%BA%E7%A1%80"><span class="toc-text">一、Web 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-web%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">1.web工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i-URL%E5%92%8CDNS%E8%A7%A3%E6%9E%90"><span class="toc-text">i. URL和DNS解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ii-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-text">ii. HTTP协议详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1"><span class="toc-text">2.搭建Web服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-web%E5%B7%A5%E4%BD%9C"><span class="toc-text">3.web工作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A1%A8%E5%8D%95"><span class="toc-text">二、表单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5"><span class="toc-text">1.验证表单输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E9%80%92%E4%BA%A4%E8%A1%A8%E5%8D%95"><span class="toc-text">2. 防止多次递交表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">3. 处理文件上传</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">三、访问数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-sql%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.sql接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">2.PostgreSQL数据库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-text">四、session和数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-cookie%E5%92%8Csession"><span class="toc-text">1.cookie和session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-session%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.session管理设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">五、文本文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JSON%E5%A4%84%E7%90%86"><span class="toc-text">1.JSON处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AD%A3%E5%88%99%E5%A4%84%E7%90%86"><span class="toc-text">2.正则处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E5%A4%84%E7%90%86"><span class="toc-text">3.模板处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C"><span class="toc-text">字段操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Web%E6%9C%8D%E5%8A%A1"><span class="toc-text">六、Web服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Socket%E7%BC%96%E7%A8%8B"><span class="toc-text">1.Socket编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-WebSocket"><span class="toc-text">2.WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Rest"><span class="toc-text">3.Rest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-RPC"><span class="toc-text">4.RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8DSQL%E6%B3%A8%E5%85%A5"><span class="toc-text">5.避免SQL注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%AE%BE%E8%AE%A1Web%E6%A1%86%E6%9E%B6"><span class="toc-text">七、设计Web框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E8%A7%84%E5%88%92"><span class="toc-text">1.项目规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE"><span class="toc-text">2.自定义路由设置</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 仙逆源</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9cd4XzMOvu5xGFMhqmfNFrOr-gzGzoHsz',
      appKey: 'GRInfoqADDIeH40oSHWmxdJX',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="25" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>